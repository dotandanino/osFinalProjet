        -:    0:Source:server.cpp
        -:    1:#include <iostream>
        -:    2:#include <sys/socket.h>
        -:    3:#include <arpa/inet.h>
        -:    4:#include <unistd.h>
        -:    5:#include <string.h>
        -:    6:#include <poll.h>
        -:    7:#include <unistd.h>
        -:    8:#include "../question7/Graph.hpp"
        -:    9:#include "../question7/algoFactory.hpp"
        -:   10:#include <thread>
        -:   11:#include <mutex>
        -:   12:#include <vector>
        -:   13:#include <queue>
        -:   14:#include <condition_variable>
        -:   15:#include <algorithm>
        -:   16:#include <atomic>
        -:   17:
        -:   18:#define PORT 8080
        -:   19:#define BUFFERSIZE 4096
        -:   20:using namespace std;
        -:   21:#define N 5
        -:   22:std::mutex mtx1,mtx2,mtx3,mtx4,mtx5,mtx6; // Mutex for thread safety
        -:   23:std::condition_variable cv1,cv2,cv3,cv4,cv5,cv6; // Condition variables for signaling
        -:   24:
        -:   25:int fd_count = 2;
        -:   26:vector<pollfd> fds(fd_count);
        -:   27:
        -:   28:
        -:   29:struct toqueue {
        -:   30:    int fd;
        -:   31:    std::string result;
        -:   32:    Graph g;
        -:   33:};
        -:   34:std::queue<int> q1; // Queue to hold file descriptors
        -:   35:std::queue<toqueue> q2,q3,q4,q5,q6;
        -:   36:
        -:   37:std::unique_ptr<GraphAlgorithm> algo1 = createAlgorithm(static_cast<AlgorithmType>(1));
        -:   38:std::unique_ptr<GraphAlgorithm> algo2 = createAlgorithm(static_cast<AlgorithmType>(2));
        -:   39:std::unique_ptr<GraphAlgorithm> algo3 = createAlgorithm(static_cast<AlgorithmType>(3));
        -:   40:std::unique_ptr<GraphAlgorithm> algo4 = createAlgorithm(static_cast<AlgorithmType>(4));
        -:   41:
        3:   42:Graph createRandomGraph(int numOfVertex, int numOfEdges, int RandomSeed,int minWeight, int maxWeight) {
        3:   43:    unsigned long maxEdge = (numOfVertex -1)*numOfVertex;
        3:   44:    if((unsigned long)numOfEdges>maxEdge){
        1:   45:        throw std::runtime_error("You entered too many edges");
        -:   46:        exit(1);
        -:   47:    }
        2:   48:    int edgesAdded=0;
        2:   49:    Graph g(numOfVertex);
        1:   50:    srand(RandomSeed);
       44:   51:    while(edgesAdded<numOfEdges){
       43:   52:        int src=rand()%numOfVertex;
       43:   53:        int dest =rand()%numOfVertex;
       43:   54:        int weight = rand() % (maxWeight - minWeight + 1) + minWeight;
        -:   55:        try{
       43:   56:            g.addDirectedEdge(src,dest,weight);
       40:   57:            edgesAdded++;
        3:   58:        }catch(const std::exception& e){
        -:   59:            //nothing to do here just wait for another graph
        3:   60:        }
        -:   61:    }
        1:   62:    return g;
    =====:   63:}
        -:   64:
        -:   65:std::atomic<bool> server_running(true); // Flag to control server running state
        -:   66:
        2:   67:void maxFlow(){
        5:   68:    while(server_running) {
        5:   69:        Graph g(1);//temp
        5:   70:        int fd = -1;
        -:   71:        {
        5:   72:            std::unique_lock<std::mutex> lock(mtx2);
       15:   73:            cv2.wait(lock, []{ return !q2.empty() || !server_running;}); // Wait until there is something in the queue
        5:   74:            if(!q2.empty()) {
        3:   75:                auto item = q2.front();
        3:   76:                q2.pop();
        3:   77:                fd = item.fd;
        3:   78:                g = item.g;
        3:   79:            }
        5:   80:        }
        5:   81:        if(fd == -1 && !server_running) {
        2:   82:            break; // Exit if server is not running and no file descriptor is available
        -:   83:        }
       3*:   84:        if (fd == -1) {
    #####:   85:            continue;
        -:   86:        }
        3:   87:        std::string result = algo1->execute(g);
        -:   88:        {
        3:   89:            std::lock_guard<std::mutex> lock(mtx3);
        3:   90:            q3.push({fd, result, g});
        3:   91:            cv3.notify_one();
        3:   92:        }
        5:   93:    }
        5:   94:}
        -:   95:
        2:   96:void MST(){
        5:   97:    while(server_running) {
        5:   98:        Graph g(1);//temp
        5:   99:        std::string result;
        5:  100:        int fd = -1;
        -:  101:        {
        5:  102:            std::unique_lock<std::mutex> lock(mtx3);
       15:  103:            cv3.wait(lock, []{ return !q3.empty() || !server_running;}); // Wait until there is something in the queue
        5:  104:            if(!q3.empty()) {
        3:  105:                auto item = q3.front();
        3:  106:                q3.pop();
        3:  107:                fd = item.fd;
        3:  108:                g = item.g;
        3:  109:                result = item.result;
        3:  110:            }
        5:  111:        }
        5:  112:        if(fd == -1 && !server_running) {
        2:  113:            break; // Exit if server is not running and no file descriptor is available
        -:  114:        }
       3*:  115:        if (fd == -1) {
    #####:  116:            continue;
        -:  117:        }
        3:  118:        result +="\n";
        3:  119:        result += algo2->execute(g);
        -:  120:        {
        3:  121:            std::lock_guard<std::mutex> lock(mtx4);
        3:  122:            q4.push({fd, result, g});
        3:  123:            cv4.notify_one();
        3:  124:        }
        7:  125:    }
        5:  126:}
        -:  127:
        2:  128:void PathCover(){
        5:  129:    while(server_running) {
        5:  130:        Graph g(1);//temp
        5:  131:        std::string result;
        5:  132:        int fd = -1;
        -:  133:        {
        5:  134:            std::unique_lock<std::mutex> lock(mtx4);
       15:  135:            cv4.wait(lock, []{ return !q4.empty() || !server_running; }); // Wait until there is something in the queue
        5:  136:            if(!q4.empty()) {
        3:  137:                auto item = q4.front();
        3:  138:                q4.pop();
        3:  139:                fd = item.fd;
        3:  140:                g = item.g;
        3:  141:                result = item.result;
        3:  142:            }
        5:  143:        }
        5:  144:        if(fd == -1 && !server_running) {
        2:  145:            break; // Exit if server is not running and no file descriptor is available
        -:  146:        }
       3*:  147:        if (fd == -1) {
    #####:  148:            continue;
        -:  149:        }
        3:  150:        result += "\n";
        3:  151:        result += algo3->execute(g);
        -:  152:        {
        3:  153:            std::lock_guard<std::mutex> lock(mtx5);
        3:  154:            q5.push({fd, result, g});
        3:  155:            cv5.notify_one();
        3:  156:        }
        7:  157:    }
        5:  158:}
        -:  159:
        -:  160:
        2:  161:void SCC(){
        5:  162:    while(server_running) {
        5:  163:        Graph g(1);//temp
        5:  164:        std::string result;
        5:  165:        int fd = -1;
        -:  166:        {
        5:  167:            std::unique_lock<std::mutex> lock(mtx5);
       15:  168:            cv5.wait(lock, []{ return !q5.empty() || !server_running; }); // Wait until there is something in the queue
        5:  169:            if(!q5.empty()) {
        3:  170:                auto item = q5.front();
        3:  171:                q5.pop();
        3:  172:                fd = item.fd;
        3:  173:                g = item.g;
        3:  174:                result = item.result;
        3:  175:            }
        5:  176:        }
        5:  177:        if(fd == -1 && !server_running) {
        2:  178:            break; // Exit if server is not running and no file descriptor is available
        -:  179:        }
       3*:  180:        if (fd == -1) {
    #####:  181:            continue;
        -:  182:        }
        3:  183:        result += "\n";
        3:  184:        result += algo4->execute(g);
        -:  185:        {
        3:  186:            std::lock_guard<std::mutex> lock(mtx6);
        3:  187:            q6.push({fd, result, g});
        3:  188:            cv6.notify_one();
        3:  189:        }
        7:  190:    }
        5:  191:}
        -:  192:
        -:  193:
        2:  194:void senderHandle(){
        5:  195:    while(server_running) {
        5:  196:        int fd=-1;
        5:  197:        string result;
        -:  198:        {
        5:  199:            std::unique_lock<std::mutex> lock(mtx6);
       15:  200:            cv6.wait(lock, []{ return !q6.empty() || !server_running;}); // Wait until there is something in the queue
        5:  201:            if(!q6.empty()) {
        3:  202:                toqueue item = q6.front();
        3:  203:                fd = item.fd;
        3:  204:                result = item.result;
        3:  205:                q6.pop();
        3:  206:            }
        5:  207:        }
        5:  208:        if(fd == -1 && !server_running) {
        2:  209:            break; // Exit if server is not running and no file descriptor is available
        -:  210:        }
       3*:  211:        if (fd == -1) {
    #####:  212:            continue;
        -:  213:        }
        3:  214:        send(fd, result.c_str(), result.size(), 0);
        5:  215:    }
        2:  216:}
        -:  217:
        -:  218:
        2:  219:int main(){
        -:  220:    int server_fd;
        -:  221:    struct sockaddr_in address;
        2:  222:    int opt = 1;
        2:  223:    int addrlen = sizeof(address);
       12:  224:    std::thread threads[5];
        2:  225:    threads[0] = std::thread(maxFlow);
        2:  226:    threads[1] = std::thread(MST);
        2:  227:    threads[2] = std::thread(PathCover);
        2:  228:    threads[3] = std::thread(SCC);
        2:  229:    threads[4] = std::thread(senderHandle);
        -:  230:
        -:  231:    // create the socket
        2:  232:    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    #####:  233:        perror("socket failed");
    #####:  234:        exit(EXIT_FAILURE);
        -:  235:    }
        -:  236:
        -:  237:    // set socket options to allow reuse of the address and port
        2:  238:    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
    #####:  239:        perror("setsockopt failed");
    #####:  240:        exit(EXIT_FAILURE);
        -:  241:    }
        -:  242:    
        2:  243:    address.sin_family = AF_INET;
        2:  244:    address.sin_addr.s_addr = INADDR_ANY;
        2:  245:    address.sin_port = htons(PORT);
        -:  246:    
        -:  247:    // connect the socket to the address and port
        2:  248:    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
    #####:  249:        perror("bind failed");
    #####:  250:        exit(EXIT_FAILURE);
        -:  251:    }
        -:  252:
        -:  253:    // create a queue with 10 places for the socket to listen for incoming connections
        2:  254:    if (listen(server_fd, 10) < 0) {
    #####:  255:        perror("listen failed");
    #####:  256:        exit(EXIT_FAILURE);
        -:  257:    }
        -:  258:    // a vector to hold the file descriptors for polling
        2:  259:    fds[0].fd = server_fd;
        2:  260:    fds[0].events = POLLIN;
        2:  261:    fds[1].fd = STDIN_FILENO; // Add stdin to the poll list
        2:  262:    fds[1].events = POLLIN;
        -:  263:
        -:  264:    int buffer[BUFFERSIZE / sizeof(int)];
        -:  265:    for(;;){
       13:  266:        int poll_count = poll(fds.data(), fd_count, -1);
       13:  267:        if (poll_count < 0) {
    #####:  268:            perror("poll failed");
    #####:  269:            exit(EXIT_FAILURE);
        -:  270:        }
       48:  271:        for(int i=0;i<fd_count;i++){
       37:  272:            if(fds[i].revents & POLLIN){
       13:  273:                if(fds[i].fd == server_fd){
        2:  274:                    int new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen);
        2:  275:                    fds.push_back({new_socket, POLLIN});
        2:  276:                    fd_count++;
        -:  277:                }
       11:  278:                else if(fds[i].fd == STDIN_FILENO){
        -:  279:                    // Handle input from stdin
        2:  280:                    string input;
        2:  281:                    cin >> input;
        2:  282:                    if(input == "exit") {
        2:  283:                        server_running = false;
       2*:  284:                        for(int j=2; j<fd_count; j++) {
    #####:  285:                            close(fds[j].fd); // Close all client sockets
        -:  286:                        }
        2:  287:                        close(server_fd); // Close the server socket
        2:  288:                        server_running = false; // Set the server running flag to false
        -:  289:                        {
        2:  290:                            std::lock_guard<std::mutex> lock(mtx1);
        2:  291:                            cv1.notify_all(); // Notify all waiting threads to exit
        2:  292:                        }
        -:  293:                        {
        2:  294:                            std::lock_guard<std::mutex> lock(mtx2);
        2:  295:                            cv2.notify_all();
        2:  296:                        }
        -:  297:                        {
        2:  298:                            std::lock_guard<std::mutex> lock(mtx3);
        2:  299:                            cv3.notify_all();
        2:  300:                        }
        -:  301:                        {
        2:  302:                            std::lock_guard<std::mutex> lock(mtx4);
        2:  303:                            cv4.notify_all();
        2:  304:                        }
        -:  305:                        {
        2:  306:                            std::lock_guard<std::mutex> lock(mtx5);
        2:  307:                            cv5.notify_all();
        2:  308:                        }
        -:  309:                        {
        2:  310:                            std::lock_guard<std::mutex> lock(mtx6);
        2:  311:                            cv6.notify_all();
        2:  312:                        }
       12:  313:                        for(int i=0;i<5;i++){
       10:  314:                            threads[i].join(); // Wait for all threads to finish
        -:  315:                        }
        2:  316:                        exit(0);
        -:  317:                    }
    #####:  318:                }
        -:  319:                else{
        9:  320:                    int byteRecv = recv(fds[i].fd,buffer,BUFFERSIZE,0);
        9:  321:                    if(byteRecv==0){
        2:  322:                        close(fds[i].fd);
        2:  323:                        fds.erase(fds.begin() + i);
        2:  324:                        fd_count--;
        7:  325:                        continue;
        -:  326:                    }
        7:  327:                    int n=buffer[0];
        7:  328:                    if(n == 0) {
        5:  329:                        int numOfVertex = buffer[1];
        5:  330:                        int numOfEdges = buffer[2];
        5:  331:                        int RandomSeed = buffer[3];
        5:  332:                        int minWeight = buffer[4];
        5:  333:                        int maxWeight = buffer[5];
        5:  334:                        if (minWeight > maxWeight) {
        2:  335:                            string e = "Error: minWeight cannot be greater than maxWeight";
        2:  336:                            send(fds[i].fd, e.c_str(), e.size(), 0);
        2:  337:                            continue;
        2:  338:                        }
        -:  339:                        try{
        3:  340:                            Graph g = createRandomGraph(numOfVertex, numOfEdges, RandomSeed,minWeight, maxWeight);
        -:  341:                            {
        1:  342:                                std::lock_guard<std::mutex> lock(mtx2);
        2:  343:                                q2.push({fds[i].fd, "", g});
        1:  344:                                cv2.notify_one();
        1:  345:                            }
        1:  346:                        }
        2:  347:                        catch(const std::exception& e){
        2:  348:                            string errorMsg = "Error creating random graph: " + std::string(e.what());
        2:  349:                            send(fds[i].fd, errorMsg.c_str(), errorMsg.size(), 0);
        2:  350:                        }
        3:  351:                        continue;
        3:  352:                    }
        -:  353:
        2:  354:                    vector<vector<int>> neighborsMatrix(n, vector<int>(n, -1));
       12:  355:                    for(int i=0;i<n;i++){
       60:  356:                        for(int j=0;j<n;j++){
       50:  357:                            neighborsMatrix[i][j]=buffer[i*n+j+1];
        -:  358:                        }
        -:  359:                    }
        2:  360:                    Graph g(n,neighborsMatrix);
        -:  361:                    {
        2:  362:                        std::lock_guard<std::mutex> lock(mtx2);
        4:  363:                        q2.push({fds[i].fd, "", g});
        2:  364:                        cv2.notify_one();
        2:  365:                    }
        2:  366:                }
        -:  367:            }
        -:  368:        }
       11:  369:    }
        9:  370:}
